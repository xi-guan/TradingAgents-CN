#!/usr/bin/env python3
"""
从 config/local.yaml 生成 .env 文件
Generate .env file from config/local.yaml
"""

import os
import sys
from pathlib import Path
from typing import Any, Dict

try:
    import yaml
except ImportError:
    print("错误: 需要安装 PyYAML")
    print("请运行: pip install pyyaml")
    sys.exit(1)


def flatten_dict(d: Dict[str, Any], parent_key: str = '', sep: str = '_') -> Dict[str, Any]:
    """
    将嵌套字典扁平化为环境变量格式

    Args:
        d: 输入字典
        parent_key: 父键名
        sep: 分隔符

    Returns:
        扁平化的字典
    """
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}".upper() if parent_key else k.upper()

        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        elif isinstance(v, list):
            # 列表转换为逗号分隔的字符串
            items.append((new_key, ','.join(map(str, v))))
        elif v is None:
            items.append((new_key, ''))
        else:
            items.append((new_key, str(v)))

    return dict(items)


def generate_env_file(config_path: Path, output_path: Path):
    """
    从YAML配置生成.env文件

    Args:
        config_path: 配置文件路径
        output_path: 输出.env文件路径
    """
    # 读取YAML配置
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)

    # 扁平化配置
    env_vars = flatten_dict(config)

    # 生成.env文件
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("# TradingAgents-CN Environment Variables\n")
        f.write(f"# Auto-generated from {config_path}\n")
        f.write("# DO NOT EDIT THIS FILE MANUALLY\n")
        f.write("\n")

        # 按照分类组织环境变量
        categories = {
            'APP_': '应用配置',
            'DATABASE_': '数据库配置',
            'SECURITY_': '安全配置',
            'DATA_SOURCES_': '数据源配置',
            'LLM_': 'LLM API配置',
            'LOGGING_': '日志配置',
            'CACHE_': '缓存配置',
            'LIMITS_': '限流配置',
            'CORS_': 'CORS配置',
            'UPLOAD_': '文件上传配置',
            'SCHEDULER_': '任务调度配置',
            'PROXY_': '代理配置',
        }

        # 按分类写入
        for prefix, category_name in categories.items():
            category_vars = {k: v for k, v in env_vars.items() if k.startswith(prefix)}
            if category_vars:
                f.write(f"\n# {category_name}\n")
                for key, value in sorted(category_vars.items()):
                    # 处理特殊字符（需要引号）
                    if ' ' in str(value) or ',' in str(value):
                        f.write(f'{key}="{value}"\n')
                    else:
                        f.write(f'{key}={value}\n')

        # 写入未分类的变量
        uncategorized = {
            k: v for k, v in env_vars.items()
            if not any(k.startswith(prefix) for prefix in categories.keys())
        }
        if uncategorized:
            f.write("\n# 其他配置\n")
            for key, value in sorted(uncategorized.items()):
                if ' ' in str(value) or ',' in str(value):
                    f.write(f'{key}="{value}"\n')
                else:
                    f.write(f'{key}={value}\n')

    print(f"✅ .env 文件已生成: {output_path}")
    print(f"   共 {len(env_vars)} 个环境变量")


def main():
    """主函数"""
    # 获取项目根目录
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent

    config_path = project_root / "config" / "local.yaml"
    env_path = project_root / ".env"

    # 检查配置文件是否存在
    if not config_path.exists():
        print(f"❌ 错误: 配置文件不存在: {config_path}")
        print("   请先运行 ./scripts/setup.sh 生成配置文件")
        sys.exit(1)

    # 生成.env文件
    try:
        generate_env_file(config_path, env_path)
    except Exception as e:
        print(f"❌ 错误: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
